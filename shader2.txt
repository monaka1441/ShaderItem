サーフェスシェーダとテクスチャマッピング
この章では、Surface Shadersについて説明します。
私たちは非常にシンプルなマット素材から始め、ホログラフィック・アドバンスと高度な地形を融合させて終了します。テクスチャを使用して、必要な他のプロパティをアニメーション化し、ブレンドし、ドライブすることもできます。この章では、以下の方法について学習します。
・拡散シャーディング
・パックド配列の使用
・シェーダにテクスチャを追加する
・UV値を変更してテクスチャをスクロールする
・Normal mapping
・透明な素材を作成する
・ホログラフィックシェーダの作成
・テクスチャのパッキングとブレンド
・あなたの地形の周りに円を作成する
p22
サーフェスシェーダは、第1章「最初のシェーダの作成」で、Unityで使用される主なシェーダタイプとして導入されています。この章では、これらの実際の内容とその働きについて詳しく説明します。一般に、すべてのSurface Shaderには2つの重要なステップがあります。最初に、散布色、滑らかさ、透明度など、説明したいマテリアルの特定の物理的特性を指定する必要があります。これらのプロパティは、サーフェス関数と呼ばれる関数で初期化され、サーフェス出力と呼ばれる構造体に格納されます。第2に、表面出力が照明モデルに渡される。これは、シーン内の近くのライトに関する情報も取得する特別な機能です。これらのパラメータを使用して、モデルの各ピクセルの最終的な色を計算します。ライティング関数は、シェイダーの実際の計算が、マテリアルに触れたときの光の振る舞いを決定するコードの一部として行われる場所です。

次の図は、Surface Shaderの動作を概略しています。Custumライティングモデルについては第3章「ライティングモデルの理解」で、第5章「頂点関数」では頂点モディファイアに焦点を当てて説明します。

p23
拡散シェーディング実世界全体では、純粋な散布材は存在しません。 拡散シェーダは、実装するのが比較的安価であり、低ポリスの美学を備えたゲームでは大きなアプリケーションを見つけることができます。
テクスチャマッピングへの旅を始める前に、拡散したマテリアルの仕組みを理解することが重要です。特定のオブジェクトは、均一な色と滑らかな表面を持ちますが、反射光を照らすほど滑らかではありません。これらのマット素材は、Diffuseシェーダで最もよく表現されます。

準備中
独自のDiffuseシェーダを作成する方法はいくつかあります。簡単な方法は、第1章「最初のシェーダを作成する」ですでに行ったことと同様に、Unity 5のStandard Shaderで始まり、それを編集してテクスチャを削除することです。
p24
このシェーダは標準シェーダから再構成されているため、モデル上での光の振る舞いをシミュレートするために物理的なレンダリングを使用します。フォトリアリスティックでない外観を実現しようとしている場合は、最初の#pragmaディレクティブをStandardよりLambertを使用するように変更することができます。そうした場合は、SurefaceOutputStandardをSurfaecOutputに置き換える必要があります

How it work
シェーダが素材のレンダリングプロパティをライティングモデルに伝えることができる方法は、サーフェス出力です。これは基本的に、現在の照明モデルのニーズに対するすべてのパラメータのラッパーです。さまざまな照明モデルが異なる表面出力構造を持っていることを驚かすべきではありません。次の表は、Unity 5で使用される3つの主要な出力構造体とその使用方法を示しています。

図は本を参照

サーフェスシェーダを正しく使用するには、サーフェスの出力を正しい値で初期化する必要があります。


p28
シェーダにテクスチャを追加する

テクスチャは、非常に現実的な効果を達成するという観点から、シェーダの寿命を非常に短くします。テクスチャを効果的に使用するには、2D画像を3Dモデルにマッピングする方法を理解する必要があります。このプロセスはテクスチャマッピングと呼ばれ、使用したいシェーダと3Dモデルでいくつかの作業を行う必要があります。実際、モデルは三角形から作られています。 各頂点は、シェーダがアクセスできるデータを格納することができます。UVデータの頂点に格納される最も重要な情報の1つ.UとVの2つの座標（0?1）で構成されます。それらは、頂点にマップされる2D画像内のピクセルのXY位置を表す。 UVデータは頂点に対してのみ存在します。 三角形の内側の点がテクスチャマッピングされなければならない場合、GPUは最も近いUV値を補間して、使用されるテクスチャ内の右側のピクセルを見つける。次の図は、2Dテクスチャを3Dモデルから三角形にマップする方法を示しています。
UVデータは3Dモデルに保存され、モデリングソフトウェアを編集する必要があります。一部のモデルにはUV成分がないため、テクスチャマッピングをサポートできません。 例えば、スタンフォードバニーはもともとはスタンダードバニーではなかった。

準備中
このレシピでは、UVデータとそのテクスチャを備えた3Dモデルが必要です。 彼らは開始する前にUnityにインポートする必要があります。あなたはエディタにドラッグすることでこれを簡単に行うことができます。 標準シェーダはデフォルトでテクスチャマッピングをサポートしているので、これを使用して、それがどのように動作するかを詳細に説明します。

p29
How it works...
マテリアルのインスペクタから標準シェーダを使用する場合、テクスチャマッピングの背後にあるプロセスは完全に透明でデベロッパーになります。どのように動作するかを理解したい場合は、TextureShaderを詳しく見ていく必要があります。プロパティセクションからアルベド（RGB）テクスチャが実際に_MainTexとしてコード内で参照されていることがわかります。

CGPROGRAMセクションでは、このテクスチャは2Dテクスチャの標準タイプであるsampler2Dとして定義されています。

p30
次の行にInputという構造体があります。 これはサーフェス関数の入力パラメータで、uv_MainTexというパックド配列が含まれています。
surf（）サーフェス関数が呼び出されるたびに、入力構造には、レンダリングが必要な3Dモデルの特定の点の_MainTexのUVが含まれます。標準シェーダは、名前uv_MainTexが_MainTexを参照し、それを自動的に初期化することを認識します。実際にUVが3D空間から2Dテクスチャにどのようにマップされているかを理解することに興味がある場合は、第3章「照明モデルの理解」を参照してください。
最後に、UVデータを使用してサーフェスファンクションの最初の行のテクスチャをサンプリングします。

これはCgのtex2D（）関数を使って行います。 テクスチャとUVを取り、その位置のピクセルの色を返します。

UとVの座標は0から1になります。ここで（0,0）と（1,1）は2つの反対側のコーナーに対応します。異なる実装はUVを異なるコーナーに関連付けます。 テクスチャが反転して見える場合は、Vコンポーネントを反転させてみてください。

There's more...
Unityにテクスチャをインポートするときには、sampler2Dが使用するいくつかのプロパティを設定しています。
最も重要なのは、フィルタモードで、テクスチャがサンプリングされるときにどのように色が補間されるかを決定します。
UVデータがピクセルの中心を正確に指すことはほとんどありません。 それ以外の場合は、より均一な色を得るために最も近いピクセルの間を補間したいかもしれません。
 以下は、テクスチャのインスペクタタブのスクリーンショットです：

p31
ほとんどのアプリケーションでは、Bilinearはテクスチャを滑らかにするための安価で効果的な方法を提供します。ただし、2Dゲームを作成している場合は、Bilinearによってぼかしたタイルが生成されることがあります。 この場合、Pointを使用して、テクスチャのサンプリングから補間を削除することができます。テクスチャが急な角度から見られるとき、テクスチャサンプリングは視覚的に不快なアーティファクトを生成する可能性がある。Aniso Levelをより高い値に設定することでそれらを減らすことができます。これは、グリッチが連続性の錯覚を破ることができる床と天井のテクスチャに特に便利です。テクスチャが3Dサーフェスにどのようにマップされているかの内部作業の詳細を知りたい場合は、以下のURLを参照
http;//developer.nvidia.com/CgTurorial/cg_tutorial_chapter03.html.

p32
2Dテクスチャをインポートするときに使用できるオプションの完全なリストについては、次のWebサイトを参照してください。
http://docs.unity3d.com/Manual/class-TextureImporter.html

UV値を変更してテクスチャをスクロールする
今日のゲーム業界で使用されている最も一般的なテクスチャテクニックの1つは、オブジェクトの表面上でテクスチャをスクロールするプロセスです。これにより、滝、川、ラカ流などのエフェクトを作成することができます。これは、アニメーション化されたスプライト効果を作成するための基礎でもあるテクニックですが、この章の後のレシピでこれをカバーします。最初にサーフェスシェーダで簡単なスクロール効果を作成する方法を見てみましょう。

Getting ready
このレシピを開始するには、新しいシェーダファイルとマテリアルを作成する必要があります。 これは、スクロール効果を単独で調べるのに使うことができる、きれいなシェーダで私たちを設定します。

How to do it
まず、作成した新しいシェーダファイルを起動し、次の手順で記述したコードを入力します。

1:シェーダには、テクスチャスクロールの速度を制御できる2つの新しいプロパティが必要です。 そこで、次のコードに示すように、X方向の速度プロパティとY方向の速度プロパティを追加しましょう：

2:CGPROGRAMセクションのCgプロパティを変更し、プロパティから値にアクセスできるように新しい変数を作成します。

3:サーフェス関数を変更して、tex2D（）関数に渡されたUVを変更します。 次に、組み込みの_Time変数を使用して、エディタで再生ボタンが押されたときにUVをアニメーション化します。

p33
次の図は、スクロールするuvシステムを使用して、環境に合わせた簡単な河川の動きを作成した結果を示しています。 ScrollingUVsというシーンで、この本で扱っているコードファイルからこの効果がわかります：

P34
How it works...
スクロールシステムは、2つのプロパティの宣言で始まります。このプロパティを使用すると、スクロールエフェクト自体の速度を増減できます。コアの中には、材料のインスペクタタブからシェーダのサーフェス関数に渡される浮動小数点演算があります。シェーダのプロパティの詳細については、第1章「最初のシェーダの作成」を参照してください。

マテリアルインスペクタタブからこれらの浮動小数点値を取得したら、それらを使用してシェーダのUV係数をオフセットすることができます。

この問題を解決するために、最初にUVをscrolledUVという別の変数に格納します。 UV値が入力構造体から渡されるので、この変数はfloat2 / fixed2でなければなりません：

メッシュのUVにアクセスすると、スクロール速度変数と組み込み_Time 値を使用してそれらをオフセットできます。この組み込み変数はfloat4型の変数を返します。つまり、この変数の各コンポーネントには異なる時間値が含まれています それはゲーム時間に関係するからです。これらの個々の時間値の完全な説明は、次のリンクで説明されています。
http://docs.unity3d.com/Manual/SL-UnityShaderVariables.html

この_Time変数は、Unityのゲームタイムクロックに基づく浮動小数点値を返します。したがって、この値を使用してUVをUV方向に移動し、その時間をスクロール速度変数でスケーリングすることができます：

正しいオフセットを時間で計算すると、新しいオフセット値を元のUV位置に戻すことができます。このため、次の行で+ =演算子を使用しています。元のUV位置を取得し、新しいオフセット値を追加し、これをテクスチャの新しいUVとしてtex2D（）関数に渡したいとします。これは、表面上を移動するテクスチャの効果を作り出します。私たちは実際に私たちを操作しているので、テクスチャ移動の効果を偽っています：



